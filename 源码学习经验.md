##  (一) 对象中是否存在，不存在添加key，存在添加到value

```js
let __list = {};

function add(key, fn) {
	// 不存在key
	if(!this.__list[key]) {
		this.__list[key] = [];
	}
	// 添加到指定key的value
	this.__list[key].push(fn);
}
```

## （二）方法参数arguments对象 转成 数组Array

```js
function mySlice() {
	let arrs = Array.prototype.slice.call(arguments);
}

mySlice("key1", "key2");	//输出：["key1", "key2"]
```

```js
// slice大致实现
Array.prototype.slice = function (start, end) {
	var result = new Array()
	start = start || 0;
	end = end || this.length;
    // this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象
	for(var i = start; i < end; i++) {
		result.push(this[i]);
	}
	return result;
}
```

## （三）清空数组（length = 0 ，可以清空数组 ？？？）

```js
let arrs = [123, 456];
/*
	一. arrs = []的缺陷，在赋值前，其它变量也引用了该数组，是不会受到影响
	1.1创建一个新的空数组[]
	1.2将其引用赋值给arrs
*/

    let copyArrs = arrs;
    arrs = [];
    console.log(arrs, copyArrs) // [] [123, 456] 

/*
	二. 正确用法： arrs.length = 0，效率也会更高
*/
	let copyArrs = arrs;
	arrs.length = 0;
	console.log(arrs, copyArrs) // [] []
```

