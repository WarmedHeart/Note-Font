1. 用户界面：前进、后退、刷新所在栏。

2. 浏览器引擎：用户界面和呈现引擎之间发送指令。

3. 渲染引擎：解析请求的内容并呈现在屏幕上。<span style="color:red">每个标签页分别对应一个渲染引擎。</span>

4. 网络：网络调用，HTTP请求。

5. 用户界面后端：绘制每个节点

6. JavaScript解释器：解析执行JavaScript代码

7. 数据存储：比如Cookie

   

   **渲染引擎主流程：**

   ![img](02浏览器是如何运行_img/webkitflow.png)

### HTML解析生成解析树

**首先**将文档转换成另一种格式：

词法分析器：将输入内容分解成一个个**有效标记**。

HTML解析器：根据语言的上下文相关语法规则分析文档的结构，两两配对，构建解析树。

示例 - 解析 2 + 3 - 1 这个表达式，会返回下面的**解析树**：由DOM元素和属性节点构成的树结构：

![img](02浏览器是如何运行_img/image009.png)

解析算法：边识别标记，边传递给树构造器，如此反复。

**其次**将解析树翻译成机器代码文档：

### CSS解析生成样式表

理论上来说，应用样式表不会更改 DOM 树，因此似乎没有必要等待样式表并停止文档解析。但这涉及到一个问题，就是脚本在文档解析阶段会请求样式信息。如果当时还没有加载和解析样式，脚本就会获得错误的回复，这样显然会产生很多问题。这看上去是一个非典型案例，但事实上非常普遍。Firefox 在样式表加载和解析的过程中，会禁止所有脚本。而对于 WebKit 而言，仅当脚本尝试访问的样式属性可能受尚未加载的样式表影响时，它才会禁止该脚本。

### JavaScript解析

解析器遇到 <script> 标记时立即解析并执行脚本。文档的解析将停止，直到脚本执行完毕。

HTML5可将脚本标记为异步。

**预解析**，在执行脚本时，其他线程会解析文档的其余部分，找出并加载需要通过网络加载的其他资源。通过这种方式，资源可以在并行连接上加载，从而提高总体速度。请注意，预解析器不会修改 DOM 树，而是将这项工作交由主解析器处理；预解析器只会解析外部资源（例如外部脚本、样式表和图片）的引用。

### 构建呈现树

在 DOM 树构建的同时，浏览器还会构建另一个树结构：呈现树。由可视化元素按照其显示顺序而组成的树。

呈现器是和 DOM 元素相对应的，但并非一一对应。display 属性值为“none”，那么也不会显示在呈现树中（但是 visibility 属性值为“hidden”的元素仍会显示）。

### 布局

### 绘制